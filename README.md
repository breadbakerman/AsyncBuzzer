<svg
	xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 1372.201 1372.684" style="float: right; margin: 0 4px; position: relative; z-index: 1; filter: drop-shadow(0 2px 4px #00000066);">
	<path fill="#00979D" stroke="#81C9CB" stroke-miterlimit="10" stroke-width=".932" d="M1371.701 686.024c0 378.658-306.972 685.605-685.549 685.605C307.451 1371.629.5 1064.682.5 686.024.5 307.455 307.451.483 686.152.483c378.594.001 685.549 306.972 685.549 685.541z"/>
	<linearGradient id="a" x1="-16.3" x2="1354.901" y1="16.071" y2="16.071" gradientTransform="matrix(1 0 0 -1 16.8 702.696)" gradientUnits="userSpaceOnUse">
		<stop offset=".117" stop-color="#fff" stop-opacity="0"/>
		<stop offset=".252" stop-color="#c0d1d3" stop-opacity=".153"/>
		<stop offset=".387" stop-color="#91b3b7" stop-opacity=".306"/>
		<stop offset=".52" stop-color="#6d9fa3" stop-opacity=".457"/>
		<stop offset=".65" stop-color="#4d9195" stop-opacity=".604"/>
		<stop offset=".776" stop-color="#30888b" stop-opacity=".746"/>
		<stop offset=".895" stop-color="#148386" stop-opacity=".881"/>
		<stop offset="1" stop-color="#008184"/>
	</linearGradient>
	<linearGradient id="b" x1="-16.8" x2="1355.401" y1="16.071" y2="16.071" gradientTransform="matrix(1 0 0 -1 16.8 702.696)" gradientUnits="userSpaceOnUse">
		<stop offset="0" stop-color="#fff" stop-opacity="0"/>
		<stop offset=".153" stop-color="#c0d1d3" stop-opacity=".153"/>
		<stop offset=".306" stop-color="#91b3b7" stop-opacity=".306"/>
		<stop offset=".457" stop-color="#6d9fa3" stop-opacity=".457"/>
		<stop offset=".604" stop-color="#4d9195" stop-opacity=".604"/>
		<stop offset=".746" stop-color="#30888b" stop-opacity=".746"/>
		<stop offset=".881" stop-color="#148386" stop-opacity=".881"/>
		<stop offset="1" stop-color="#008184"/>
	</linearGradient>
	<path fill="url(#a)" stroke="url(#b)" stroke-miterlimit="10" d="M1371.701 686.595c0 378.65-306.972 685.606-685.549 685.606C307.451 1372.201.5 1065.23.5 686.595.5 308.019 307.451 1.048 686.152 1.048c378.594.016 685.549 306.97 685.549 685.547z" opacity=".5"/>
	<g fill="#FFF">
		<path d="M947.959 931.196c-12.909 0-26.127-.929-39.127-2.864-108.978-15.554-181.848-93.822-222.665-153.989-40.946 60.166-113.811 138.512-222.74 154.045a275.864 275.864 0 0 1-39.133 2.785c-67.753 0-131.358-25.217-179.201-71.003-48.299-46.165-74.951-108.114-74.951-174.171 0-66.14 26.651-128.004 75.021-174.253 47.797-45.793 111.449-70.936 179.231-70.936 12.918 0 26.067.928 39.023 2.783 108.932 15.535 181.794 93.813 222.743 153.99 40.825-60.177 113.689-138.432 222.658-153.99 13-1.863 26.148-2.783 39.066-2.783 67.753 0 131.401 25.208 179.197 70.936 48.345 46.249 74.937 108.113 74.937 174.253 0 66.057-26.524 128.006-74.868 174.171-47.881 45.785-111.434 71.026-179.191 71.026M734.42 686.024c21.283 40.534 84.067 141.676 186.692 156.375 8.984 1.236 18.028 1.923 26.839 1.923 92.185 0 167.225-71.002 167.225-158.322s-75.023-158.321-167.291-158.321c-8.812 0-17.853.629-26.753 1.921-102.644 14.664-165.428 115.806-186.712 156.424M424.393 527.702c-92.308 0-167.36 70.998-167.36 158.321 0 87.305 75.021 158.322 167.245 158.322 8.852 0 17.897-.688 26.879-1.922 102.629-14.697 165.394-115.783 186.689-156.375-21.237-40.535-84.061-141.761-186.689-156.376-8.877-1.341-17.945-1.97-26.764-1.97"/>
		<path d="M354.37 662.051h152.625v49.181H354.37zm662.114 0h-51.671v-51.747h-49.348v51.747h-51.648v49.181h51.648v51.737h49.348v-51.737h51.671z"/>
	</g>
</svg>
<svg
	xmlns="http://www.w3.org/2000/svg" width="50" height="50" preserveAspectRatio="xMidYMid" viewBox="0 0 256 256" style="float: right; margin: 0 4px; position: relative; z-index: 1; filter: drop-shadow(0 2px 4px #00000066);">
	<path fill="#FF7F00" d="M128 0C93.81 0 61.666 13.314 37.49 37.49 13.314 61.666 0 93.81 0 128c0 34.19 13.314 66.334 37.49 90.51C61.666 242.686 93.81 256 128 256c34.19 0 66.334-13.314 90.51-37.49C242.686 194.334 256 162.19 256 128c0-34.19-13.314-66.334-37.49-90.51C194.334 13.314 162.19 0 128 0"/>
	<path fill="#FFF" d="M249.386 128c0 67.04-54.347 121.386-121.386 121.386C60.96 249.386 6.613 195.04 6.613 128 6.613 60.96 60.96 6.614 128 6.614c67.04 0 121.386 54.346 121.386 121.386"/>
	<path fill="#E57200" d="m160.869 74.062 5.145-18.537c5.264-.47 9.392-4.886 9.392-10.273 0-5.7-4.62-10.32-10.32-10.32s-10.32 4.62-10.32 10.32c0 3.755 2.013 7.03 5.01 8.837l-5.05 18.195c-14.437-3.67-26.625-3.39-26.625-3.39l-2.258 1.01v140.872l2.258.753c13.614 0 73.177-41.133 73.323-85.27 0-31.624-21.023-45.825-40.555-52.197zM146.53 164.8c-11.617-18.557-6.706-61.751 23.643-67.925 8.32-1.333 18.509 4.134 21.51 16.279 7.582 25.766-37.015 61.845-45.153 51.646zm18.216-39.752a9.399 9.399 0 0 0-9.399 9.399 9.399 9.399 0 0 0 9.4 9.399 9.399 9.399 0 0 0 9.398-9.4 9.399 9.399 0 0 0-9.399-9.398zm2.81 8.672a2.374 2.374 0 1 1 0-4.749 2.374 2.374 0 0 1 0 4.749z"/>
	<path fill="#FF7F00" d="m101.371 72.709-5.023-18.901c2.874-1.832 4.786-5.04 4.786-8.701 0-5.7-4.62-10.32-10.32-10.32-5.699 0-10.319 4.62-10.319 10.32 0 5.682 4.592 10.289 10.267 10.317L95.8 74.378c-19.609 6.51-40.885 20.742-40.885 51.88.436 45.01 59.572 85.267 73.186 85.267V68.892s-12.252-.062-26.729 3.817zm10.395 92.09c-8.138 10.2-52.735-25.88-45.154-51.645 3.002-12.145 13.19-17.612 21.511-16.28 30.35 6.175 35.26 49.369 23.643 67.926zm-18.82-39.46a9.399 9.399 0 0 0-9.399 9.398 9.399 9.399 0 0 0 9.4 9.4 9.399 9.399 0 0 0 9.398-9.4 9.399 9.399 0 0 0-9.399-9.399zm-2.81 8.671a2.374 2.374 0 1 1 0-4.748 2.374 2.374 0 0 1 0 4.748z"/>
</svg>


# AsyncBuzzer Library
[![Library Compile Test](https://github.com/breadbakerman/AsyncBuzzer/actions/workflows/compile.yml/badge.svg)](https://github.com/breadbakerman/AsyncBuzzer/actions/workflows/compile.yml)

A non-blocking Arduino library for controlling buzzers with support for beeps, pulses, and tone sequence playback.

## Features

- **Non-blocking operation**: Uses `update()` calls instead of `delay()` for timing
- **Multiple sound types**: Single beeps, pulse sequences, pattern sequences, melody playback, and tone sequence playback
- **Melody independence**: Melodies play independently and don't interfere with beep, pulse, or pattern functions
- **Individual tone control**: Each tone can have its own rest period for precise timing control
- **Pattern support**: Play complex sequences of pulse groups with configurable delays
- **SD card support**: Load melodies and patterns from SD card files with simple text formats (optional)
- **Configurable settings**: Separate settings for acknowledgment and error sounds
- **Memory efficient**: Configurable limits for melody and pattern arrays
- **Hardware flexible**: Use pin 255 to disable buzzer functionality, automatic pin mode configuration

## Installation

1. Copy the `AsyncBuzzer` folder to your Arduino libraries directory
2. Include the header in your sketch: `#include <AsyncBuzzer.h>`

## Examples

The library includes example sketches to demonstrate usage:

- **Beep**: Basic beeping functionality with timed intervals
- **Pulse**: Pulse patterns with different timing configurations

Access examples in the Arduino IDE via File → Examples → AsyncBuzzer.

## Configuration

The library can be configured through compile-time definitions in an optinal `config.h` or before including the header:

```cpp
#define BUZZER_USE_SD            // Enable SD card support (requires SDCard library)
#define BUZZER_SERIAL_DISABLE    // Disable serial output (set if SERIAL_OUT_DISABLE is defined)
#define BUZZER_PIN A1            // Pin for buzzer
#define BUZZER_ACK_FREQ 4000     // Frequency for acknowledgment beep (Hz)
#define BUZZER_ACK_DURATION 20   // Duration for acknowledgment beep (ms)
#define BUZZER_ACK_REST 80       // Rest period after acknowledgment beep (ms)
#define BUZZER_ERR_FREQ 100      // Frequency for error beep (Hz)
#define BUZZER_ERR_DURATION 300  // Duration for error beep (ms)
#define BUZZER_ERR_REST 150      // Rest period after error beep (ms)
#define BUZZER_PULSE_INTERVAL 80 // Default interval between pulses (ms) - for backward compatibility
#define BUZZER_MAX_MELODY_TONES 30    // Maximum number of tones in a melody
#define BUZZER_MAX_PATTERN_PULSES 20  // Maximum number of pulses in a pattern
```

### ANSI Color Configuration

The library supports optional ANSI color codes for serial output. If not defined in your `config.h`, they default to empty strings (no colors). To enable colored output, define these in your `config.h`:

```cpp
#define ANSI_GRAY "\e[38;5;8m"      // Gray color for log prefixes
#define ANSI_DEFAULT "\e[1;37m"     // Default white color
#define ANSI_YELLOW "\e[38;5;11m"   // Yellow color for values
#define ANSI_ERROR "\e[38;5;9m"     // Red color for errors
#define ANSI_CURSORUP "\e[1A"       // Move cursor up (for file playback)
#define ANSI_CLEAREOL "\e[0K"       // Clear to end of line
```

The library automatically provides fallback empty definitions if these are not defined, ensuring compilation compatibility regardless of whether color support is configured.

## API Reference

Many functions accept optional flags to control their behavior and timing.

### Setup Functions

```cpp
// Initialize with pin and optional flags
bool setup(uint8_t pin = BUZZER_PIN, uint8_t flags = BUZ_NONE);

// Initialize with full configuration
bool setup(Config conf, uint8_t flags = BUZ_NONE);
```

**Flags:**
- `BUZ_NONE`: No special behavior
- `BUZ_BEEP`: Play initialization beep sequence
- `BUZ_SILENT`: Suppress console output
- `BUZ_FORCE`: Force re-initialization even if pin hasn't changed

### Configuration Management

```cpp
// Get current configuration
Config getConfig();

// Set new configuration
Config setConfig(Config conf, uint8_t flags = BUZ_NONE);
```

### Sound Functions

```cpp
// Single beep with specified frequency and duration
void beep(uint16_t frequency = getConfig().ack.frequency,
          uint16_t duration = getConfig().ack.duration);

// Non-blocking pulse sequence
void pulse(uint8_t count = 3,
           uint16_t frequency = getConfig().ack.frequency,
           uint16_t duration = getConfig().ack.duration,
           uint16_t rest = getConfig().ack.rest);

// Blocking pulse sequence (waits until complete)
void pulseBlocking(uint8_t count = 3,
                   uint16_t frequency = getConfig().ack.frequency,
                   uint16_t duration = getConfig().ack.duration,
                   uint16_t rest = getConfig().ack.rest);

// Play tone sequence from SD card (requires BUZZER_USE_SD)
bool playFile(const String &path, uint8_t flags = BUZ_NONE);

// Pattern playback - play sequence of pulse groups
void pattern(Pulse* pulses, uint8_t count, bool repeat = false, uint16_t pulseDelay = 300);

// Blocking pattern playback (waits until complete)
void patternBlocking(Pulse* pulses, uint8_t count, bool repeat = false, uint16_t pulseDelay = 300);

// Check if pattern is currently playing
bool isPatternActive();

// Stop current pattern immediately
void stopPattern();

// Load pattern from SD card file (requires BUZZER_USE_SD)
uint8_t loadPattern(const String &path, Pulse *pulses, uint8_t flags = BUZ_NONE);

// Melody playback - play sequence of tones (non-interfering with other sounds)
void melody(Tone *tones, uint8_t count, bool repeat = false);

// Blocking melody playback (waits until complete)
void melodyBlocking(Tone *tones, uint8_t count, bool repeat = false);

// Check if melody is currently playing
bool isMelodyActive();

// Stop current melody immediately
void stopMelody();

// Load melody from SD card file (requires BUZZER_USE_SD)
uint8_t loadTones(const String &path, Tone *tones, uint8_t flags = BUZ_NONE);
```

### Update Function

Non-blocking pulse sequences, patterns, and melodies require regular `update()` calls to function properly.
```cpp
// Must be called regularly in main loop for non-blocking operation
bool update();
```

## Configuration Structures

### Tone Structure
```cpp
struct Tone {
    uint16_t frequency;  // Frequency in Hz
    uint16_t duration;   // Duration in milliseconds
    uint16_t rest;       // Rest period after tone in milliseconds
};
```

### Config Structure
```cpp
struct Config {
    uint8_t pin;    // Buzzer pin (255 = disabled)
    Tone ack;       // Acknowledgment tone settings
    Tone err;       // Error tone settings
};
```

### Pulse Structure
```cpp
struct Pulse {
    uint8_t pulses;      // Number of beeps in this pulse group
    uint16_t frequency;  // Tone frequency in Hz
    uint16_t duration;   // Duration of each beep in milliseconds
    uint16_t interval;   // Time between beeps in this pulse group
    uint32_t last;       // Runtime field - last beep timestamp
    bool active;         // Runtime field - pulse group active state
};
```

### Pattern Structure
```cpp
struct Pattern {
    Pulse* pulses;          // Array of pulse definitions
    uint8_t count;          // Number of pulses in pattern
    uint8_t current;        // Current pulse index (runtime)
    bool active;            // Pattern active state (runtime)
    bool repeat;            // Should pattern repeat when finished
    uint16_t pulseDelay;    // Delay between pulse groups in milliseconds
    uint32_t lastPulseEnd;  // When last pulse finished (runtime)
    bool waitingForDelay;   // Waiting for delay between pulses (runtime)
};
```

## Usage Examples

### Basic Setup and Usage

```cpp
#include <AsyncBuzzer.h>

void setup() {
    // Initialize buzzer on pin A1 with startup beep
    AsyncBuzzer::setup(A1, BUZ_BEEP);
}

void loop() {
    // Must call update() for non-blocking operation
    AsyncBuzzer::update();

    // Your other code here
    if (someCondition) {
        AsyncBuzzer::beep();  // Quick acknowledgment beep
    }

    if (errorCondition) {
        AsyncBuzzer::pulse(5);  // 5-pulse error sequence
    }
}
```

### Custom Configuration

```cpp
void setup() {
    // Create custom configuration
    AsyncBuzzer::Config conf;
    conf.pin = A1;
    conf.ack = {2000, 50, 100};  // 2kHz, 50ms duration, 100ms rest
    conf.err = {500, 200, 150};  // 500Hz, 200ms duration, 150ms rest

    AsyncBuzzer::setup(conf);
}
```

### Runtime Configuration Changes

```cpp
void changeSettings() {
    AsyncBuzzer::Config conf = AsyncBuzzer::getConfig();
    conf.ack.frequency = 3000;  // Change ack frequency to 3kHz
    conf.ack.rest = 80;         // Change ack rest period to 80ms
    conf.err.duration = 500;    // Change error duration to 500ms
    AsyncBuzzer::setConfig(conf);
}
```

### Pattern Sequences

```cpp
// Define pattern arrays as global/static for persistence
AsyncBuzzer::Pulse startupPattern[] = {
    AsyncBuzzer::Pulse(1, 440, 100, 0),   // A4 note
    AsyncBuzzer::Pulse(1, 554, 100, 0),   // C#5 note
    AsyncBuzzer::Pulse(1, 659, 200, 0)    // E5 note
};

AsyncBuzzer::Pulse alarmPattern[] = {
    AsyncBuzzer::Pulse(3, 1000, 100, 100), // 3 high beeps
    AsyncBuzzer::Pulse(1, 500, 500, 0),    // 1 long low beep
    AsyncBuzzer::Pulse(2, 800, 150, 200)   // 2 medium beeps
};

void setup() {
    AsyncBuzzer::setup(A1);

    // Play startup melody once with 200ms between pulse groups
    AsyncBuzzer::pattern(startupPattern, 3, false, 200);
}

void triggerAlarm() {
    // Play alarm pattern repeatedly with 500ms between pulse groups
    AsyncBuzzer::pattern(alarmPattern, 3, true, 500);
}

void stopAlarm() {
    if (AsyncBuzzer::isPatternActive()) {
        AsyncBuzzer::stopPattern();
    }
}
```

### Blocking Pattern for Initialization

```cpp
void setup() {
    AsyncBuzzer::setup(A1);

    // Play startup sequence and wait for completion
    AsyncBuzzer::patternBlocking(startupPattern, 3, false, 300);

    // This code runs after pattern completes
    Serial.println("Startup sequence complete");
}
```

### Melody Playback

```cpp
// Define melody as Tone array
AsyncBuzzer::Tone imperialMarch[BUZZER_MAX_MELODY_TONES];
AsyncBuzzer::Tone twinkleTwinkle[] = {
    AsyncBuzzer::Tone(262, 400, 100),  // C4
    AsyncBuzzer::Tone(262, 400, 100),  // C4
    AsyncBuzzer::Tone(392, 400, 100),  // G4
    AsyncBuzzer::Tone(392, 400, 100),  // G4
    AsyncBuzzer::Tone(440, 400, 100),  // A4
    AsyncBuzzer::Tone(440, 800, 200),  // A4 (longer)
    AsyncBuzzer::Tone(392, 800, 400)   // G4 (longer with pause)
};

void setup() {
    AsyncBuzzer::setup(A1);

    // Load melody from SD card
    uint8_t toneCount = AsyncBuzzer::loadTones("/sound/imperial", imperialMarch);
    if (toneCount > 0) {
        AsyncBuzzer::melody(imperialMarch, toneCount, true); // repeat
    }
}

void playTwinkle() {
    // Play predefined melody once
    AsyncBuzzer::melody(twinkleTwinkle, 7, false);
}

void stopBackgroundMusic() {
    if (AsyncBuzzer::isMelodyActive()) {
        AsyncBuzzer::stopMelody();
    }
}
```

### Loading Patterns from SD Card

```cpp
AsyncBuzzer::Pulse alarmPattern[BUZZER_MAX_PATTERN_PULSES];

void loadAndPlayAlarm() {
    // Load pattern from SD card file
    uint8_t pulseCount = AsyncBuzzer::loadPattern("/sound/alarm.pat", alarmPattern);

    if (pulseCount > 0) {
        AsyncBuzzer::pattern(alarmPattern, pulseCount, true, 500); // repeat with 500ms delay
    } else {
        Serial.println("Failed to load alarm pattern");
    }
}
```

### Sound File Playback (with SD support)

The playFile function supports the same format as melody files but plays them immediately using blocking delays. The key difference is that it reads a file line by line, allowing melodies of any length to be played.

```cpp
// Sound file format:
// # play
// # frequency, duration, rest
// 1000, 100, 50
// 800, 150, 100

void playSoundFile() {
    if (!AsyncBuzzer::playFile("/sounds/startup.txt")) {
        Serial.println("Failed to play sound file");
    }
}
```

## Sound File Formats

When using SD card support, the library supports multiple file formats:

### Melody Files (for loadTones and melody functions)

```
# play
frequency, duration, rest
frequency, duration, rest
...
```

- `# play`: required prologue
- `frequency`: Tone frequency in Hz (0 = rest/silence)
- `duration`: Tone duration in milliseconds
- `rest`: Silent period after tone in milliseconds
- Values are comma-separated
- Lines starting with `#` are comments
- Empty lines are ignored

Example melody file (`imperial.txt`):
```
# play
# Imperial March
440, 500, 150
440, 500, 150
440, 500, 150
349, 350, 105
523, 150, 45
440, 500, 150
```

### Pattern Files (for loadPattern and pattern functions)

```
# pattern
pulses, frequency, duration, interval
pulses, frequency, duration, interval
...
```

- `# pattern`: required prologue
- `pulses`: Number of beeps in this pulse group
- `frequency`: Tone frequency in Hz
- `duration`: Duration of each beep in milliseconds
- `interval`: Time between beeps in this pulse group
- Values are comma-separated
- Lines starting with `#` are comments
- Empty lines are ignored

Example pattern file (`alarm.pat`):
```
# pattern
# Braun Alarm Clock
4, 2000, 150, 100
4, 2000, 150, 100
4, 2000, 150, 100
```

## Dependencies

- Arduino core libraries
- `config.h` (optional, auto-detected for project-specific settings)
- `SDCard.h` (optional, auto-detected for SD card file playback)

## Notes

- Always call `AsyncBuzzer::update()` in your main loop for proper non-blocking operation
- Starting a new pattern or pulse automatically stops any current pattern
- Sound file playback is blocking and uses `delay()` internally
- Memory limits: Melody arrays are limited by `BUZZER_MAX_MELODY_TONES`, pattern arrays by `BUZZER_MAX_PATTERN_PULSES`
- Pattern pulse delay accounts for the last beep's duration to ensure accurate timing
- Use pin 255 to disable the buzzer functionality
- The library automatically handles pin mode configuration

## License

MIT License - Copyright (c) 2025 by breadbaker
